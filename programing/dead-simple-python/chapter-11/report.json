{
    "data": "<!DOCTYPE html>\n<html lang=\"zh-CN\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>攻击路径图 - 无相AI</title>\n\n    <!-- 内联样式：完全自包含，无外网依赖 -->\n    <style>\n        /* 深色主题 CSS 变量 - 用于攻击路径图 */\n        :root {\n            /* 背景色系 */\n            --color-bg-primary: #0d1117;\n            --color-bg-panel: #161b22;\n            --color-bg-card: #1c2027;\n            --color-bg-card-light: #252a33;\n            --color-bg-hover: #30363d;\n\n            /* 文本色系 */\n            --color-text-primary: rgba(255, 255, 255, 0.85);\n            --color-text-secondary: rgba(255, 255, 255, 0.55);\n            --color-text-disabled: #484f58;\n            --color-text-error: #ea4335;\n\n            /* 边框与分割线 */\n            --color-border: #515968;\n            --color-border-light: #484f58;\n            --color-border-dark: #3b434e;\n            --color-divider: #21262d;\n        }\n\n        /* 基础重置和字体 */\n        * {\n            margin: 0;\n            padding: 0;\n            box-sizing: border-box;\n        }\n\n        body {\n            font-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", \"Microsoft YaHei\", \"Noto Sans SC\", sans-serif;\n            background-color: #f3f4f6;\n            color: #1f2937;\n            line-height: 1.5;\n        }\n\n        /* 时序图样式 - 深色主题 */\n        .timeline-container {\n            background: var(--color-bg-panel);\n            border: 1px solid var(--color-border);\n            border-radius: 0.5rem;\n            padding: 1.5rem;\n            margin-bottom: 2rem;\n            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);\n            overflow: visible;\n        }\n\n        .sequence-diagram {\n            position: relative;\n            width: 100%;\n            min-height: 400px;\n            height: calc(100vh - 500px);\n            /* 基于视口高度，减去其他内容的高度 */\n            max-height: 90vh;\n            /* 最大高度限制 */\n            overflow: hidden;\n            /* 裁剪超出内容，支持拖拽查看 */\n            padding: 0;\n            background: var(--color-bg-primary);\n            border-radius: 0.5rem;\n            cursor: grab;\n            /* 鼠标样式：抓取 */\n            user-select: none;\n            /* 防止拖拽时选中文本 */\n            touch-action: none;\n            /* 禁用浏览器默认触摸行为，完全由JS控制 */\n        }\n\n        .sequence-diagram.dragging {\n            cursor: grabbing;\n            /* 拖拽中：抓取中 */\n        }\n\n        .sequence-diagram-inner {\n            position: relative;\n            width: 100%;\n            min-height: 100%;\n            /* 允许根据内容自动扩展 */\n            /* transform 由 JavaScript 动态设置 */\n            will-change: transform;\n            /* 性能优化提示 */\n        }\n\n        .sequence-diagram .participants {\n            display: flex;\n            justify-content: space-around;\n            padding: 0 2rem;\n            margin-bottom: 1rem;\n            min-width: fit-content;\n            position: relative;\n            z-index: 5;\n        }\n\n        .sequence-diagram .participants-bottom {\n            display: flex;\n            justify-content: space-around;\n            padding: 0 2rem;\n            margin-top: 1rem;\n            min-width: fit-content;\n            position: relative;\n            z-index: 5;\n        }\n\n        .sequence-diagram .participant {\n            flex: 1 1 0;\n            min-width: 0;\n            text-align: center;\n            position: relative;\n            display: flex;\n            flex-direction: column;\n            justify-content: center;\n            align-items: center;\n            padding: 0 0.5rem;\n            z-index: 5;\n        }\n\n        .sequence-diagram .participant-box {\n            background: var(--color-bg-card);\n            border: 2px solid #3b82f6;\n            border-radius: 0.375rem;\n            padding: 0.75rem 1rem;\n            margin: 0;\n            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);\n            width: 100%;\n            /* max-width 和 min-width 由 JavaScript 动态设置 */\n            box-sizing: border-box;\n            display: flex;\n            flex-direction: column;\n            justify-content: center;\n            align-items: center;\n            text-align: center;\n            position: relative;\n            z-index: 1;\n            word-wrap: break-word;\n            overflow-wrap: break-word;\n            white-space: normal;\n        }\n\n        .sequence-diagram .participant-name {\n            font-weight: 600;\n            color: var(--color-text-primary);\n            font-size: 0.875rem;\n            margin: 0;\n            padding: 0;\n            text-align: center;\n            width: 100%;\n            word-wrap: break-word;\n            overflow-wrap: break-word;\n            white-space: normal;\n        }\n\n        .sequence-diagram .participant-alias {\n            font-size: 0.75rem;\n            color: var(--color-text-secondary);\n            margin: 0.25rem 0 0 0;\n            padding: 0;\n            text-align: center;\n            width: 100%;\n            word-wrap: break-word;\n            overflow-wrap: break-word;\n            white-space: normal;\n        }\n\n        .sequence-diagram .participant-line {\n            position: absolute;\n            left: 50%;\n            width: 0;\n            border-left: 2px dashed var(--color-border);\n            transform: translateX(-50%);\n            z-index: 1;\n            /* top 和 height 由JavaScript动态设置，确保精确连接上下节点边缘 */\n        }\n\n        .sequence-diagram .messages {\n            position: relative;\n            display: flex;\n            /* 使用 Flexbox 垂直排列 */\n            flex-direction: column;\n            /* 垂直排列 */\n            gap: 1.5rem;\n            /* 使用 gap 控制间距，替代固定 margin */\n            min-height: 200px;\n            margin: 1rem 0;\n            z-index: 6;\n            padding-bottom: 1rem;\n        }\n\n        .sequence-diagram .message {\n            position: relative;\n            /* 移除 margin，使用父容器的 gap 控制间距 */\n            min-height: 60px;\n            /* 确保有足够高度容纳标签和箭头 */\n            padding-top: 1rem;\n            /* 为向上偏移的标签留出空间 */\n            /* 移除 z-index，避免创建新的层叠上下文，让标签的 z-index 在 .messages 层级生效 */\n        }\n\n        .sequence-diagram .message-line {\n            position: absolute;\n            height: var(--message-line-width, 2px);\n            background: #3b82f6;\n            z-index: 2;\n        }\n\n        .sequence-diagram .message-arrow {\n            position: absolute;\n            width: 0;\n            height: 0;\n            border-style: solid;\n            z-index: 3;\n        }\n\n        .sequence-diagram .message-arrow.right {\n            border-width: 6px 0 6px 10px;\n            border-color: transparent transparent transparent #3b82f6;\n        }\n\n        .sequence-diagram .message-arrow.left {\n            border-width: 6px 10px 6px 0;\n            border-color: transparent #3b82f6 transparent transparent;\n        }\n\n        .sequence-diagram .message-label {\n            position: absolute;\n            top: -0.75rem;\n            left: 50%;\n            transform: translateX(-50%);\n            background: transparent;\n            padding: 0.25rem 0.5rem;\n            border-radius: 0;\n            font-size: 0.75rem;\n            color: var(--color-text-primary);\n            box-shadow: none;\n            z-index: 100;\n            cursor: pointer;\n            pointer-events: auto;\n            /* 使用flexbox垂直布局，确保simple和details垂直排列 */\n            display: flex;\n            flex-direction: column;\n            align-items: flex-start;\n        }\n\n        /* 默认显示的简化内容（time + title） */\n        .sequence-diagram .message-label-simple {\n            display: block;\n            white-space: nowrap;\n            /* max-width 由 JavaScript 动态设置 */\n            overflow: hidden;\n            text-overflow: ellipsis;\n            /* 确保不被覆盖，不收缩 */\n            flex-shrink: 0;\n        }\n\n        /* 默认隐藏的详细信息 */\n        .sequence-diagram .message-label-details {\n            display: none;\n            white-space: normal;\n            /* max-width 由 JavaScript 动态设置 */\n            line-height: 1.5;\n            margin-top: 0.25rem;\n            padding-top: 0.25rem;\n            border-top: 1px solid var(--color-divider);\n            /* 确保在simple下方，不收缩 */\n            flex-shrink: 0;\n            width: 100%;\n            box-sizing: border-box;\n        }\n\n        /* hover 时显示详细信息在标题下方 */\n        .sequence-diagram .message-label:hover .message-label-details {\n            display: block;\n        }\n\n        /* hover 时调整标签样式，确保有足够空间显示详细信息 */\n        .sequence-diagram .message-label:hover {\n            z-index: 10000;\n            padding-top: 0.25rem;\n            padding-bottom: 0.75rem;\n            background: var(--color-bg-card);\n            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4);\n            border-radius: 0.25rem;\n            /* 保持flex布局 */\n            display: flex;\n            flex-direction: column;\n        }\n\n        /* 时间样式 */\n        .sequence-diagram .message-time {\n            color: var(--color-text-secondary);\n            font-size: 0.7rem;\n            margin-right: 0.5rem;\n        }\n\n        /* 标题样式 */\n        .sequence-diagram .message-title {\n            font-weight: 600;\n            color: var(--color-text-secondary);\n            font-size: 0.875rem;\n        }\n    </style>\n</head>\n\n<body>\n    <div class=\"timeline-container\">\n        <div id=\"timeline-diagram\" class=\"sequence-diagram\"></div>\n    </div>\n    <script type=\"application/json\"\n        id=\"timeline-data\">{\"messages\": [{\"content\": \"\\u901a\\u8fc7\\u9493\\u9c7c\\u90ae\\u4ef6\\u8bf1\\u4f7f\\u7528\\u6237\\u6267\\u884c\\u6076\\u610f\\u9644\\u4ef6\\u003cbr\\u003e\\u6210\\u529f\\u83b7\\u53d6\\u7ba1\\u7406\\u5458\\u6743\\u9650\", \"from\": \"attacker\", \"severity\": \"medium\", \"time\": \"2023-08-23 18:00:00\", \"title\": \"\\u9493\\u9c7c\\u90ae\\u4ef6\\u5165\\u4fb5\", \"to\": \"host_a\", \"type\": \"solid\"}, {\"content\": \"\\u4f7f\\u7528\\u5f31\\u5bc6\\u7801\\u0027admin/admin\\u0027\\u6210\\u529fSSH\\u767b\\u5f55\\u003cbr\\u003e\\u7528\\u6237\\uff1aroot\\u003cbr\\u003e\\u8fdb\\u7a0b\\uff1asshd(2345)\", \"from\": \"host_a\", \"severity\": \"high\", \"time\": \"2023-08-23 18:15:00\", \"title\": \"SSH\\u5f31\\u5bc6\\u7801\\u767b\\u5f55\", \"to\": \"host_b\", \"type\": \"solid\"}, {\"content\": \"\\u5229\\u7528\\u672a\\u4fee\\u8865\\u7684CVE-2023-XXXX\\u6f0f\\u6d1e\\u8fdc\\u7a0b\\u6267\\u884c\\u4ee3\\u7801\\u003cbr\\u003e\\u8fdb\\u7a0b\\uff1aexploit(1234)\", \"from\": \"host_b\", \"severity\": \"high\", \"time\": \"2023-08-23 18:30:00\", \"title\": \"\\u6f0f\\u6d1e\\u5229\\u7528\\u6a2a\\u5411\\u79fb\\u52a8\", \"to\": \"host_c\", \"type\": \"solid\"}, {\"content\": \"\\u66b4\\u529b\\u7834\\u89e3\\u6210\\u529f\\u767b\\u5f55RDP\\u003cbr\\u003e\\u7528\\u6237\\uff1aAdministrator\\u003cbr\\u003e\\u8fdb\\u7a0b\\uff1awinlogon.exe(6789)\", \"from\": \"host_b\", \"severity\": \"high\", \"time\": \"2023-08-23 18:45:00\", \"title\": \"RDP\\u66b4\\u529b\\u7834\\u89e3\", \"to\": \"host_d\", \"type\": \"solid\"}, {\"content\": \"\\u901a\\u8fc7FTP\\u4f20\\u8f93\\u654f\\u611f\\u6570\\u636e\\u81f3C2\\u670d\\u52a1\\u5668\\u003cbr\\u003e\\u6587\\u4ef6\\u8def\\u5f84\\uff1a/var/data/sensitive_info.zip\", \"from\": \"host_c\", \"severity\": \"high\", \"time\": \"2023-08-23 19:00:00\", \"title\": \"\\u6570\\u636e\\u6e17\\u51fa\", \"to\": \"c2\", \"type\": \"solid\"}], \"participants\": [{\"alias\": null, \"id\": \"attacker\", \"name\": \"\\u653b\\u51fb\\u8005\"}, {\"alias\": \"Windows\", \"id\": \"host_a\", \"name\": \"10.108.108.23\"}, {\"alias\": \"Linux\", \"id\": \"host_b\", \"name\": \"172.16.21.70\"}, {\"alias\": \"Linux\", \"id\": \"host_c\", \"name\": \"172.16.21.71\"}, {\"alias\": \"Linux\", \"id\": \"host_d\", \"name\": \"10.106.108.110\"}, {\"alias\": \"C2\", \"id\": \"c2\", \"name\": \"118.195.160.47\"}]}</script>\n\n    <script>\n        // 基准尺寸（设计稿尺寸）\n        const BASE_WIDTH = 1200;\n        const BASE_HEIGHT = 600;\n\n        // 缩放限制\n        const MIN_SCALE = 0.5;\n        const MAX_SCALE = 2.0;\n\n        // 基准尺寸常量（像素值）\n        const BASE_SIZES = {\n            participantMinWidth: 120,\n            participantMaxWidth: 200,\n            participantPadding: { x: 16, y: 12 }, // 0.75rem 1rem\n            participantBorder: 2,\n            participantFontSize: 14, // 0.875rem\n            participantAliasFontSize: 12, // 0.75rem\n            participantLineWidth: 2,\n            messageSpacing: 80,\n            messageLineHeight: 2,\n            messageArrowSize: { width: 10, height: 6 },\n            messageLabelFontSize: 12, // 0.75rem\n            messageLabelPadding: { x: 8, y: 4 }, // 0.25rem 0.5rem\n            messageLabelMaxWidth: 300,\n            messageLabelDetailsMaxWidth: 400,\n            messageTimeFontSize: 14, // 0.7rem\n            messageTitleFontSize: 14, // 0.7rem\n            messageMargin: 16, // 1rem\n            messagePaddingBottom: 16, // 1rem\n            containerPadding: 32, // 2rem\n            participantGap: 16, // 1rem\n            initialMessageY: 20 // 初始消息Y位置\n        };\n\n        // 防抖函数\n        function debounce(func, wait) {\n            let timeout;\n            return function executedFunction(...args) {\n                const later = () => {\n                    clearTimeout(timeout);\n                    func(...args);\n                };\n                clearTimeout(timeout);\n                timeout = setTimeout(later, wait);\n            };\n        }\n\n        // 计算内容所需空间（基于基准尺寸）\n        function calculateRequiredDimensions(data) {\n            // 顶部参与者区域高度（估算）\n            const topParticipantsHeight = 80; // 参与者框高度 + 间距\n            // 消息区域高度（使用估算值，Flexbox 会自动调整）\n            // 每条消息约 60px 高度 + 24px gap = 84px\n            const estimatedMessageHeight = 60; // 单条消息高度\n            const estimatedGap = 24; // 消息之间的间距\n            const messagesHeight = data.messages.length * (estimatedMessageHeight + estimatedGap);\n            // 底部参与者区域高度（估算）\n            const bottomParticipantsHeight = 80;\n            // 容器内边距\n            const containerPadding = BASE_SIZES.containerPadding * 2; // 上下各2rem\n\n            return {\n                width: BASE_WIDTH,\n                height: topParticipantsHeight + messagesHeight + bottomParticipantsHeight + containerPadding\n            };\n        }\n\n        // 计算缩放因子（基于实际内容尺寸和可用空间）\n        function calculateScale(containerWidth, containerHeight, requiredWidth, requiredHeight) {\n            // 计算基于宽度和高度的缩放因子\n            const scaleX = containerWidth / requiredWidth;\n            const scaleY = containerHeight / requiredHeight;\n            // 取较小值，确保内容完全适配\n            const scale = Math.min(scaleX, scaleY);\n            // 限制在最小和最大缩放范围内\n            return Math.max(MIN_SCALE, Math.min(scale, MAX_SCALE));\n        }\n\n        function renderSequenceDiagram(data) {\n            const container = document.getElementById('timeline-diagram');\n            if (!container || !data || !data.participants || !data.messages) {\n                return;\n            }\n\n            // 清除之前固定的高度，让容器使用 CSS 的 calc(100vh - 500px) 重新计算\n            // 这样当窗口大小变化时，容器高度能够自动适应新的窗口大小\n            container.style.height = '';\n\n            // 使用 requestAnimationFrame 等待浏览器重新计算容器高度\n            // 这样 getBoundingClientRect() 会返回基于新窗口大小的值\n            requestAnimationFrame(function () {\n                // 清空容器\n                container.innerHTML = '';\n\n                // 创建内层容器（用于拖拽平移）\n                const innerContainer = document.createElement('div');\n                innerContainer.className = 'sequence-diagram-inner';\n                container.appendChild(innerContainer);\n\n                // 创建参与者映射表\n                const participantMap = {};\n                data.participants.forEach((p, index) => {\n                    participantMap[p.id] = index;\n                });\n\n                const participantCount = data.participants.length;\n\n                // 计算内容所需空间（基于基准尺寸）\n                const requiredDimensions = calculateRequiredDimensions(data);\n\n                // 获取容器尺寸（使用 getBoundingClientRect 获取实际渲染尺寸）\n                // 现在容器高度已经基于新的窗口大小重新计算了\n                let containerRect = container.getBoundingClientRect();\n                let containerWidth = containerRect.width || container.offsetWidth || 800;\n                let containerHeight = containerRect.height || container.offsetHeight || 600;\n\n                // 如果容器高度为0或很小，使用视口高度计算\n                if (containerHeight < 100) {\n                    // 估算可用高度：视口高度减去其他内容（页眉、页脚等）\n                    const viewportHeight = window.innerHeight || 800;\n                    containerHeight = Math.max(400, viewportHeight - 400); // 预留400px给其他内容\n                }\n\n                // 根据实际内容尺寸和可用空间计算缩放因子\n                const scale = calculateScale(\n                    containerWidth,\n                    containerHeight,\n                    requiredDimensions.width,\n                    requiredDimensions.height\n                );\n\n                // 固定消息线宽度为2px，不随scale缩放\n                // 将CSS变量设置在innerContainer上，确保消息线能够正确继承\n                // 四舍五入到整数像素，避免子像素渲染问题\n                const messageLineHeight = Math.round(BASE_SIZES.messageLineHeight); // 固定值，不乘以scale，四舍五入到整数\n                innerContainer.style.setProperty('--message-line-width', messageLineHeight + 'px');\n\n                // 渲染参与者\n                const participantsDiv = document.createElement('div');\n                participantsDiv.className = 'participants';\n\n                // 计算统一的参与者框宽度（自适应但一致，考虑缩放）\n                const calculateParticipantWidth = function () {\n                    const padding = BASE_SIZES.containerPadding * scale * 2; // 左右各2rem\n                    const gap = BASE_SIZES.participantGap * scale * (participantCount - 1);\n                    const availableWidth = containerWidth - padding - gap;\n                    const calculatedWidth = Math.floor(availableWidth / participantCount);\n                    // 限制在缩放后的最小和最大宽度之间\n                    const minWidth = BASE_SIZES.participantMinWidth * scale;\n                    const maxWidth = BASE_SIZES.participantMaxWidth * scale;\n                    return Math.max(minWidth, Math.min(maxWidth, calculatedWidth));\n                };\n\n                // 设置内层容器的内边距（考虑缩放）\n                const diagramPadding = BASE_SIZES.containerPadding * scale;\n                innerContainer.style.padding = diagramPadding + 'px 0';\n\n                // 使用requestAnimationFrame确保容器宽度已确定\n                const renderParticipants = function () {\n                    const participantWidth = calculateParticipantWidth();\n\n                    // 计算缩放后的尺寸\n                    const participantPaddingX = BASE_SIZES.participantPadding.x * scale;\n                    const participantPaddingY = BASE_SIZES.participantPadding.y * scale;\n                    const participantBorder = BASE_SIZES.participantBorder * scale;\n                    const participantFontSize = BASE_SIZES.participantFontSize * scale;\n                    const participantAliasFontSize = BASE_SIZES.participantAliasFontSize * scale;\n                    const participantLineWidth = BASE_SIZES.participantLineWidth * scale;\n                    const participantsContainerPadding = BASE_SIZES.containerPadding * scale;\n                    const participantGap = BASE_SIZES.participantGap * scale;\n\n                    // 设置参与者容器的内边距\n                    participantsDiv.style.padding = '0 ' + participantsContainerPadding + 'px';\n                    participantsDiv.style.marginBottom = participantGap + 'px';\n\n                    // 创建顶部参与者\n                    data.participants.forEach((participant, index) => {\n                        const participantDiv = document.createElement('div');\n                        participantDiv.className = 'participant';\n                        participantDiv.style.padding = '0 ' + (participantGap / 2) + 'px';\n\n                        const box = document.createElement('div');\n                        box.className = 'participant-box';\n                        box.style.width = participantWidth + 'px';\n                        box.style.padding = participantPaddingY + 'px ' + participantPaddingX + 'px';\n                        box.style.borderWidth = participantBorder + 'px';\n\n                        const name = document.createElement('div');\n                        name.className = 'participant-name';\n                        name.textContent = participant.name;\n                        name.style.fontSize = participantFontSize + 'px';\n\n                        if (participant.alias && participant.alias !== participant.name) {\n                            const alias = document.createElement('div');\n                            alias.className = 'participant-alias';\n                            alias.textContent = participant.alias;\n                            alias.style.fontSize = participantAliasFontSize + 'px';\n                            box.appendChild(name);\n                            box.appendChild(alias);\n                        } else {\n                            box.appendChild(name);\n                        }\n                        participantDiv.appendChild(box);\n\n                        const line = document.createElement('div');\n                        line.className = 'participant-line';\n                        // line.style.width = participantLineWidth + 'px';\n                        participantDiv.appendChild(line);\n\n                        participantsDiv.appendChild(participantDiv);\n                    });\n\n                    innerContainer.appendChild(participantsDiv);\n\n                    // 渲染完成后继续处理消息和底部参与者\n                    renderMessages();\n                };\n\n                // 渲染消息的函数\n                const renderMessages = function () {\n                    const messagesDiv = document.createElement('div');\n                    messagesDiv.className = 'messages';\n\n                    // 计算缩放后的消息相关尺寸\n                    // 消息线宽度固定为2px，不随scale缩放（用于箭头对齐计算）\n                    const messageLineHeight = BASE_SIZES.messageLineHeight; // 固定值，不乘以scale\n                    const messageArrowWidth = BASE_SIZES.messageArrowSize.width * scale;\n                    const messageArrowHeight = BASE_SIZES.messageArrowSize.height * scale;\n                    const messageLabelFontSize = BASE_SIZES.messageLabelFontSize * scale;\n                    const messageLabelPaddingX = BASE_SIZES.messageLabelPadding.x * scale;\n                    const messageLabelPaddingY = BASE_SIZES.messageLabelPadding.y * scale;\n                    const messageLabelMaxWidth = BASE_SIZES.messageLabelMaxWidth * scale;\n                    const messageLabelDetailsMaxWidth = BASE_SIZES.messageLabelDetailsMaxWidth * scale;\n                    const messageTimeFontSize = BASE_SIZES.messageTimeFontSize * scale;\n                    const messageTitleFontSize = BASE_SIZES.messageTitleFontSize * scale;\n                    const messageMargin = BASE_SIZES.messageMargin * scale;\n                    const messagePaddingBottom = BASE_SIZES.messagePaddingBottom * scale;\n\n                    // 设置消息容器的样式\n                    messagesDiv.style.margin = messageMargin + 'px 0';\n                    messagesDiv.style.paddingBottom = messagePaddingBottom + 'px';\n                    // 设置 gap（考虑缩放），使用 Flexbox 自动控制间距\n                    const messageGap = Math.max(20 * scale, BASE_SIZES.messageSpacing * scale * 0.3); // 最小 20px，或基于基准间距的30%\n                    messagesDiv.style.gap = messageGap + 'px';\n\n                    // 计算参与者位置（使用 requestAnimationFrame 确保 DOM 已渲染）\n                    const participantPositions = [];\n                    const updateParticipantPositions = function () {\n                        const participantElements = participantsDiv.querySelectorAll('.participant');\n                        participantElements.forEach(function (element, index) {\n                            const rect = element.getBoundingClientRect();\n                            const innerRect = innerContainer.getBoundingClientRect();\n                            participantPositions[index] = rect.left - innerRect.left + rect.width / 2;\n                        });\n                    };\n\n                    // 等待DOM渲染完成后再计算位置\n                    requestAnimationFrame(function () {\n                        updateParticipantPositions();\n                        // 如果位置未计算成功，使用估算值\n                        if (participantPositions.length === 0 || participantPositions[0] === 0) {\n                            const containerWidth = container.offsetWidth || 800;\n                            const spacing = containerWidth / participantCount;\n                            data.participants.forEach(function (_, index) {\n                                participantPositions[index] = (index + 0.5) * spacing;\n                            });\n                        }\n\n                        // 按时间排序消息（方案B：日期对象排序，更健壮）\n                        const sortedMessages = [...data.messages].sort((a, b) => {\n                            const timeA = a.time || '';\n                            const timeB = b.time || '';\n\n                            // 处理不完整时间（包含XX的情况）\n                            // 将XX替换为00，或者将其排到最后\n                            const normalizeTime = (timeStr) => {\n                                if (!timeStr || timeStr.includes('XX')) {\n                                    // 不完整时间排到最后，使用一个很大的日期\n                                    return '9999-12-31 23:59:59';\n                                }\n                                return timeStr;\n                            };\n\n                            const normalizedA = normalizeTime(timeA);\n                            const normalizedB = normalizeTime(timeB);\n\n                            // 使用 Date 对象进行精确比较\n                            // 将 \"YYYY-MM-DD HH:MM:SS\" 格式转换为 \"YYYY-MM-DDTHH:MM:SS\" 以便 Date 解析\n                            const dateA = new Date(normalizedA.replace(' ', 'T'));\n                            const dateB = new Date(normalizedB.replace(' ', 'T'));\n\n                            return dateA - dateB;\n                        });\n\n                        sortedMessages.forEach((message) => {\n                            const fromIndex = participantMap[message.from];\n                            const toIndex = participantMap[message.to];\n\n                            if (fromIndex === undefined || toIndex === undefined) {\n                                return;\n                            }\n\n                            const fromX = participantPositions[fromIndex] || 0;\n                            const toX = participantPositions[toIndex] || 0;\n                            const isRight = toX > fromX;\n                            const startX = Math.min(fromX, toX);\n                            const endX = Math.max(fromX, toX);\n                            const lineLength = endX - startX;\n\n                            const messageDiv = document.createElement('div');\n                            messageDiv.className = 'message';\n                            // 移除 style.top 设置，让 Flexbox 自动处理垂直排列\n                            // 移除 style.margin 设置，使用父容器的 gap 控制间距\n                            // 设置最小高度，确保有足够空间容纳标签和箭头\n                            const minMessageHeight = Math.max(\n                                60 * scale,  // 基础高度\n                                messageLabelFontSize * 3 + messageLabelPaddingY * 2  // 标签高度\n                            );\n                            messageDiv.style.minHeight = minMessageHeight + 'px';\n                            // 设置 padding-top，为向上偏移的标签留出空间\n                            messageDiv.style.paddingTop = (16 * scale) + 'px';\n\n                            // 定义统一的基准位置（与 paddingTop 一致）\n                            const baseTop = (16 * scale);\n\n                            // 消息线（粗细由CSS变量统一控制，统一使用实线）\n                            const line = document.createElement('div');\n                            line.className = 'message-line';\n                            line.style.left = startX + 'px';\n                            line.style.width = lineLength + 'px';\n                            // height 由 CSS 变量 --message-line-width 统一控制，确保所有消息线粗细一致\n                            line.style.top = baseTop + 'px';\n                            messageDiv.appendChild(line);\n\n                            // 箭头\n                            const arrow = document.createElement('div');\n                            arrow.className = 'message-arrow ' + (isRight ? 'right' : 'left');\n                            // 方案一：箭头顶点对齐线的端点\n                            // 右箭头：顶点应该在 endX，所以 left = endX - messageArrowWidth\n                            // 左箭头：顶点应该在 startX，所以 left = startX\n                            arrow.style.left = (isRight ? (endX - messageArrowWidth) : startX) + 'px';\n                            // 垂直对齐：箭头中心与线中心对齐\n                            // 线的中心Y = baseTop + (messageLineHeight / 2)\n                            // 箭头中心Y = arrow.top + messageArrowHeight（箭头总高度12px，中心在6px处）\n                            // 要让箭头中心 = 线中心，需要：arrow.top = baseTop + (messageLineHeight / 2) - messageArrowHeight\n                            arrow.style.top = (baseTop + (messageLineHeight / 2) - messageArrowHeight) + 'px';\n                            if (isRight) {\n                                arrow.style.borderWidth = messageArrowHeight + 'px 0 ' + messageArrowHeight + 'px ' + messageArrowWidth + 'px';\n                            } else {\n                                arrow.style.borderWidth = messageArrowHeight + 'px ' + messageArrowWidth + 'px ' + messageArrowHeight + 'px 0';\n                            }\n                            messageDiv.appendChild(arrow);\n\n                            // 标签 - 双层结构：默认显示 time + title，hover 显示详细信息\n                            const label = document.createElement('div');\n                            label.className = 'message-label';\n                            label.style.left = (startX + lineLength / 2) + 'px';\n                            label.style.fontSize = messageLabelFontSize + 'px';\n                            label.style.padding = messageLabelPaddingY + 'px ' + messageLabelPaddingX + 'px';\n                            // 调整标签位置：使用 margin-top 替代 top，避免超出消息元素边界\n                            label.style.top = '0px';\n                            label.style.marginTop = '-' + (12 * scale) + 'px'; // 向上偏移，但保持在元素内\n\n                            // 简化内容（默认显示）\n                            const simpleContent = document.createElement('div');\n                            simpleContent.className = 'message-label-simple';\n                            simpleContent.style.maxWidth = messageLabelMaxWidth + 'px';\n\n                            const timeSpan = document.createElement('span');\n                            timeSpan.className = 'message-time';\n                            timeSpan.textContent = message.time || '';\n                            timeSpan.style.fontSize = messageTimeFontSize + 'px';\n\n                            const titleSpan = document.createElement('span');\n                            titleSpan.className = 'message-title';\n                            titleSpan.textContent = message.title || '';\n                            titleSpan.style.fontSize = messageTitleFontSize + 'px';\n\n                            simpleContent.appendChild(timeSpan);\n                            simpleContent.appendChild(titleSpan);\n\n                            // 详细信息（hover 显示）\n                            const detailsContent = document.createElement('div');\n                            detailsContent.className = 'message-label-details';\n                            detailsContent.innerHTML = message.content || '';\n                            detailsContent.style.maxWidth = messageLabelDetailsMaxWidth + 'px';\n                            detailsContent.style.fontSize = messageTitleFontSize + 'px';\n                            label.appendChild(simpleContent);\n                            label.appendChild(detailsContent);\n                            // 设置 hover 时的 max-width 和 padding\n                            label.addEventListener('mouseenter', function () {\n                                this.style.maxWidth = messageLabelDetailsMaxWidth + 'px';\n                                // 减小 padding-top，与默认状态保持一致\n                                this.style.paddingTop = messageLabelPaddingY + 'px'; // 保持 0.25rem\n                                this.style.paddingBottom = (messageLabelPaddingY * 3) + 'px'; // 0.75rem = 0.25rem * 3\n                            });\n                            // 恢复默认 padding（虽然默认也是这个值，但为了代码清晰可以保留）\n                            label.addEventListener('mouseleave', function () {\n                                this.style.paddingTop = messageLabelPaddingY + 'px';\n                                this.style.paddingBottom = messageLabelPaddingY + 'px';\n                            });\n                            messageDiv.appendChild(label);\n\n                            messagesDiv.appendChild(messageDiv);\n                            // 移除 messageY 累加逻辑，Flexbox 自动处理排列\n                        });\n\n                        // Flexbox 会自动计算容器高度，不再需要手动计算\n                        // 只需要设置一个最小高度作为备用\n                        // messagesDiv.style.minHeight 由 Flexbox 自动管理\n\n                        innerContainer.appendChild(messagesDiv);\n\n                        // 创建底部参与者（与顶部对称）\n                        const participantsBottomDiv = document.createElement('div');\n                        participantsBottomDiv.className = 'participants-bottom';\n\n                        const participantWidth = calculateParticipantWidth();\n                        const participantPaddingX = BASE_SIZES.participantPadding.x * scale;\n                        const participantPaddingY = BASE_SIZES.participantPadding.y * scale;\n                        const participantBorder = BASE_SIZES.participantBorder * scale;\n                        const participantFontSize = BASE_SIZES.participantFontSize * scale;\n                        const participantAliasFontSize = BASE_SIZES.participantAliasFontSize * scale;\n                        const participantsContainerPadding = BASE_SIZES.containerPadding * scale;\n                        const participantGap = BASE_SIZES.participantGap * scale;\n\n                        // 设置底部参与者容器的内边距\n                        participantsBottomDiv.style.padding = '0 ' + participantsContainerPadding + 'px';\n                        participantsBottomDiv.style.marginTop = participantGap + 'px';\n\n                        data.participants.forEach((participant, index) => {\n                            const participantDiv = document.createElement('div');\n                            participantDiv.className = 'participant';\n                            participantDiv.style.padding = '0 ' + (participantGap / 2) + 'px';\n\n                            const box = document.createElement('div');\n                            box.className = 'participant-box';\n                            box.style.width = participantWidth + 'px';\n                            box.style.padding = participantPaddingY + 'px ' + participantPaddingX + 'px';\n                            box.style.borderWidth = participantBorder + 'px';\n\n                            const name = document.createElement('div');\n                            name.className = 'participant-name';\n                            name.textContent = participant.name;\n                            name.style.fontSize = participantFontSize + 'px';\n\n                            if (participant.alias && participant.alias !== participant.name) {\n                                const alias = document.createElement('div');\n                                alias.className = 'participant-alias';\n                                alias.textContent = participant.alias;\n                                alias.style.fontSize = participantAliasFontSize + 'px';\n                                box.appendChild(name);\n                                box.appendChild(alias);\n                            } else {\n                                box.appendChild(name);\n                            }\n                            participantDiv.appendChild(box);\n                            participantsBottomDiv.appendChild(participantDiv);\n                        });\n\n                        innerContainer.appendChild(participantsBottomDiv);\n\n                        // 计算并更新参与者线的位置和长度\n                        // 需要等待DOM渲染完成后再计算，确保精确连接上下节点边缘\n                        requestAnimationFrame(function () {\n                            // Flexbox 已经自动计算了消息容器的高度，无需手动设置\n                            // 只需要确保有足够的底部间距\n                            const extraBottomSpacing = 20 * scale;\n                            messagesDiv.style.paddingBottom = (messagePaddingBottom + extraBottomSpacing) + 'px';\n\n                            // 获取参与者元素（用于后续计算和设置容器高度）\n                            const topParticipants = innerContainer.querySelector('.participants');\n                            const bottomParticipants = innerContainer.querySelector('.participants-bottom');\n\n                            // 计算实际内容总高度并动态设置容器高度\n                            if (topParticipants && bottomParticipants && messagesDiv) {\n                                // 获取各个部分的实际高度（Flexbox 自动计算）\n                                const topHeight = topParticipants.offsetHeight;\n                                const messagesHeight = messagesDiv.offsetHeight; // Flexbox 自动计算，无需手动累加\n                                const bottomHeight = bottomParticipants.offsetHeight;\n                                const containerPadding = BASE_SIZES.containerPadding * scale * 2; // 上下各2rem\n                                const messagesMargin = messageMargin * 2; // 上下各一个 margin\n                                // 获取底部参与者的 marginTop（offsetHeight 不包含 margin）\n                                const bottomMarginTop = BASE_SIZES.participantGap * scale;\n\n                                // 计算总高度（包含消息容器的 margin 和底部参与者的 marginTop）\n                                const totalContentHeight =\n                                    topHeight +\n                                    messagesHeight +\n                                    messagesMargin +\n                                    bottomHeight +\n                                    bottomMarginTop +  // 加上底部参与者的 marginTop\n                                    containerPadding;\n\n                                // 动态设置容器高度，确保内容完全显示且无滚动条\n                                container.style.height = totalContentHeight + 'px';\n                            }\n\n                            if (!topParticipants || !bottomParticipants) {\n                                return;\n                            }\n\n                            const topParticipantDivs = topParticipants.querySelectorAll('.participant');\n                            const bottomParticipantDivs = bottomParticipants.querySelectorAll('.participant');\n                            const participantLines = topParticipants.querySelectorAll('.participant-line');\n\n                            // 获取容器相对于视口的位置\n                            const containerRect = container.getBoundingClientRect();\n\n                            // 为每个参与者线单独计算精确位置\n                            participantLines.forEach(function (line, index) {\n                                const topParticipantDiv = topParticipantDivs[index];\n                                const bottomParticipantDiv = bottomParticipantDivs[index];\n\n                                if (!topParticipantDiv || !bottomParticipantDiv) {\n                                    return;\n                                }\n\n                                const topBox = topParticipantDiv.querySelector('.participant-box');\n                                const bottomBox = bottomParticipantDiv.querySelector('.participant-box');\n\n                                if (!topBox || !bottomBox) {\n                                    return;\n                                }\n\n                                // 获取各个元素的位置信息\n                                const topParticipantRect = topParticipantDiv.getBoundingClientRect();\n                                const topBoxRect = topBox.getBoundingClientRect();\n                                const bottomBoxRect = bottomBox.getBoundingClientRect();\n\n                                // 计算线应该从顶部participant div的哪个位置开始\n                                // 即：顶部框底部相对于顶部participant div顶部的偏移\n                                const lineStartOffset = topBoxRect.bottom - topParticipantRect.top;\n\n                                // 计算线的高度：从顶部框底部到底部框顶部\n                                const lineHeight = bottomBoxRect.top - topBoxRect.bottom;\n\n                                // 设置线的位置和高度\n                                line.style.top = lineStartOffset + 'px';\n                                line.style.height = Math.max(lineHeight, 0) + 'px';\n                                // 显式设置z-index，确保线在最上层（CSS已设置，这里作为双重保障）\n                                line.style.zIndex = '10';\n                            });\n\n                            // 初始化拖拽功能（在渲染完成后，等待下一个帧确保尺寸计算正确）\n                            requestAnimationFrame(function () {\n                                initDragPan(container, innerContainer);\n                            });\n                        });\n                    });\n                };\n\n                // 开始渲染：先等待容器宽度确定\n                if (container.offsetWidth === 0) {\n                    // 如果容器宽度还未确定，等待一下\n                    requestAnimationFrame(function () {\n                        requestAnimationFrame(renderParticipants);\n                    });\n                } else {\n                    renderParticipants();\n                }\n            });\n        }\n\n        // 页面加载完成后渲染时序图，并设置窗口大小变化监听\n        (function () {\n            const timelineDataElement = document.getElementById('timeline-data');\n            if (timelineDataElement) {\n                try {\n                    const timelineData = JSON.parse(timelineDataElement.textContent);\n                    if (timelineData && timelineData.participants && timelineData.messages) {\n                        const renderDiagram = function () {\n                            const container = document.getElementById('timeline-diagram');\n                            if (container) {\n                                renderSequenceDiagram(timelineData);\n                            }\n                        };\n\n                        // 初始渲染\n                        if (document.readyState === 'loading') {\n                            document.addEventListener('DOMContentLoaded', function () {\n                                renderDiagram();\n                                // 设置窗口大小变化监听\n                                setupWindowResizeListener(timelineData);\n                            });\n                        } else {\n                            renderDiagram();\n                            // 设置窗口大小变化监听\n                            setupWindowResizeListener(timelineData);\n                        }\n                    }\n                } catch (e) {\n                    console.error('Failed to parse timeline data:', e);\n                }\n            }\n        })();\n\n        // 设置窗口大小变化监听（只监听窗口变化，不监听容器尺寸变化，避免循环触发）\n        function setupWindowResizeListener(data) {\n            // 使用防抖函数包装渲染函数，避免频繁重渲染\n            const debouncedRender = debounce(function () {\n                // 重新渲染时序图\n                renderSequenceDiagram(data);\n            }, 300);\n\n            // 只监听窗口大小变化，不监听容器尺寸变化\n            // 这样可以避免 JavaScript 动态设置容器高度时触发循环渲染\n            window.addEventListener('resize', debouncedRender);\n        }\n\n        // 初始化拖拽平移功能\n        function initDragPan(container, innerContainer) {\n            // 如果已经初始化过，先移除旧的事件监听器\n            if (container._dragPanHandlers) {\n                container.removeEventListener('mousedown', container._dragPanHandlers.mouseDown);\n                document.removeEventListener('mousemove', container._dragPanHandlers.mouseMove);\n                document.removeEventListener('mouseup', container._dragPanHandlers.mouseUp);\n                container.removeEventListener('mouseleave', container._dragPanHandlers.mouseLeave);\n                container.removeEventListener('touchstart', container._dragPanHandlers.touchStart);\n                document.removeEventListener('touchmove', container._dragPanHandlers.touchMove);\n                document.removeEventListener('touchend', container._dragPanHandlers.touchEnd);\n                container.removeEventListener('touchcancel', container._dragPanHandlers.touchCancel);\n                if (container._dragPanHandlers.resize) {\n                    window.removeEventListener('resize', container._dragPanHandlers.resize);\n                }\n            }\n\n            let isDragging = false;\n            let isTouchDevice = false;\n            let startX = 0;\n            let startY = 0;\n            let currentTranslateX = 0;\n            let currentTranslateY = 0;\n            let lastTranslateX = 0;\n            let lastTranslateY = 0;\n\n            // 计算边界限制\n            function calculateBounds() {\n                const containerRect = container.getBoundingClientRect();\n\n                const containerWidth = containerRect.width;\n                const containerHeight = containerRect.height;\n\n                // 使用 scrollWidth 和 scrollHeight 获取实际内容尺寸（不受 CSS 限制影响）\n                const innerWidth = innerContainer.scrollWidth;\n                const innerHeight = innerContainer.scrollHeight;\n\n                // 如果内容小于容器，不需要拖拽\n                if (innerWidth <= containerWidth && innerHeight <= containerHeight) {\n                    return {\n                        minX: 0,\n                        maxX: 0,\n                        minY: 0,\n                        maxY: 0,\n                        canDrag: false\n                    };\n                }\n\n                // 计算可拖动的范围\n                // 当内容大于容器时，可以拖动的距离 = 内容尺寸 - 容器尺寸\n                const maxTranslateX = Math.max(0, innerWidth - containerWidth);\n                const maxTranslateY = Math.max(0, innerHeight - containerHeight);\n\n                return {\n                    minX: -maxTranslateX,\n                    maxX: 0,\n                    minY: -maxTranslateY,\n                    maxY: 0,\n                    canDrag: true\n                };\n            }\n\n            // 应用边界限制\n            function clamp(value, min, max) {\n                return Math.max(min, Math.min(max, value));\n            }\n\n            // 应用 transform\n            function applyTransform(x, y) {\n                const bounds = calculateBounds();\n                if (!bounds.canDrag) {\n                    // 如果内容小于容器，重置位置\n                    innerContainer.style.transform = 'translate(0, 0)';\n                    currentTranslateX = 0;\n                    currentTranslateY = 0;\n                    lastTranslateX = 0;\n                    lastTranslateY = 0;\n                    return;\n                }\n\n                // 应用边界限制\n                const clampedX = clamp(x, bounds.minX, bounds.maxX);\n                const clampedY = clamp(y, bounds.minY, bounds.maxY);\n\n                innerContainer.style.transform = `translate(${clampedX}px, ${clampedY}px)`;\n                currentTranslateX = clampedX;\n                currentTranslateY = clampedY;\n            }\n\n            // 统一获取事件坐标的函数\n            function getEventCoordinates(e) {\n                // 触摸事件\n                if (e.touches && e.touches.length > 0) {\n                    return {\n                        x: e.touches[0].clientX,\n                        y: e.touches[0].clientY\n                    };\n                }\n                // 鼠标事件\n                return {\n                    x: e.clientX,\n                    y: e.clientY\n                };\n            }\n\n            // 统一的开始拖拽函数（支持鼠标和触摸）\n            function handleStart(e) {\n                // 检测是否为触摸事件\n                if (e.touches) {\n                    isTouchDevice = true;\n                }\n                // 如果是触摸设备，忽略后续的鼠标事件（防止冲突）\n                if (isTouchDevice && !e.touches) {\n                    return;\n                }\n\n                // 检查是否点击在可交互元素上（如消息标签）\n                if (e.target.closest('.message-label')) {\n                    return; // 不处理，让标签的交互正常工作\n                }\n\n                // 如果是触摸事件，阻止默认行为（防止页面滚动）\n                if (e.touches) {\n                    e.preventDefault();\n                }\n\n                isDragging = true;\n                container.classList.add('dragging');\n\n                const coords = getEventCoordinates(e);\n                startX = coords.x;\n                startY = coords.y;\n                lastTranslateX = currentTranslateX;\n                lastTranslateY = currentTranslateY;\n\n                // 阻止默认行为，防止选中文本\n                e.preventDefault();\n            }\n\n            // 统一的移动函数（支持鼠标和触摸）\n            function handleMove(e) {\n                if (!isDragging) return;\n\n                // 如果是触摸设备，忽略鼠标事件\n                if (isTouchDevice && !e.touches) {\n                    return;\n                }\n\n                // 触摸事件时阻止默认行为\n                if (e.touches) {\n                    e.preventDefault();\n                }\n\n                const coords = getEventCoordinates(e);\n                const deltaX = coords.x - startX;\n                const deltaY = coords.y - startY;\n\n                const newX = lastTranslateX + deltaX;\n                const newY = lastTranslateY + deltaY;\n\n                applyTransform(newX, newY);\n            }\n\n            // 统一的结束函数（支持鼠标和触摸）\n            function handleEnd(e) {\n                if (isDragging) {\n                    isDragging = false;\n                    container.classList.remove('dragging');\n                    lastTranslateX = currentTranslateX;\n                    lastTranslateY = currentTranslateY;\n                }\n                // 延迟重置触摸设备标志，防止触摸后立即触发鼠标事件\n                if (e.changedTouches) {\n                    setTimeout(() => { isTouchDevice = false; }, 300);\n                }\n            }\n\n            // 鼠标离开容器事件\n            function handleMouseLeave() {\n                if (isDragging) {\n                    isDragging = false;\n                    container.classList.remove('dragging');\n                    lastTranslateX = currentTranslateX;\n                    lastTranslateY = currentTranslateY;\n                }\n            }\n\n            // 绑定鼠标事件（电脑端）\n            container.addEventListener('mousedown', handleStart);\n            document.addEventListener('mousemove', handleMove);\n            document.addEventListener('mouseup', handleEnd);\n            container.addEventListener('mouseleave', handleMouseLeave);\n\n            // 绑定触摸事件（手机端）\n            container.addEventListener('touchstart', handleStart, { passive: false });\n            document.addEventListener('touchmove', handleMove, { passive: false });\n            document.addEventListener('touchend', handleEnd);\n            container.addEventListener('touchcancel', handleEnd);\n\n            // 初始化位置\n            applyTransform(0, 0);\n\n            // 窗口大小变化时重新计算边界\n            const handleResize = debounce(function () {\n                applyTransform(currentTranslateX, currentTranslateY);\n            }, 100);\n            window.addEventListener('resize', handleResize);\n\n            // 保存事件处理函数引用，以便后续移除\n            container._dragPanHandlers = {\n                mouseDown: handleStart,\n                mouseMove: handleMove,\n                mouseUp: handleEnd,\n                mouseLeave: handleMouseLeave,\n                touchStart: handleStart,\n                touchMove: handleMove,\n                touchEnd: handleEnd,\n                touchCancel: handleEnd,\n                resize: handleResize\n            };\n        }\n    </script>\n</body>\n\n</html>"
}